import { Seat } from "./seat";

export class Vulnerability {
  public static None = new Vulnerability("None");
  public static NorthSouth = new Vulnerability("North / South");
  public static EastWest = new Vulnerability("East / West");
  public static All = new Vulnerability("All");

  private constructor(private vulnerability: string) {}

  public static fromString(input: string) {
    if (!input) return Vulnerability.None;

    const vulnerability = Vulnerabilities.find(
      (v) => v.vulnerability === input
    );
    if (!vulnerability) {
      throw new Error("Can't make a vulnerability from string: " + input);
    }
    return vulnerability;
  }

  static fromLin(lin: string): Vulnerability {
    const vul = {
      o: Vulnerability.None,
      0: Vulnerability.None,
      e: Vulnerability.EastWest,
      n: Vulnerability.NorthSouth,
      b: Vulnerability.All,
    }[lin.toLowerCase()];
    if (!vul) throw new Error(`Invalid lin value for vulnerability: ${lin}`);
    return vul;
  }

  toString() {
    return this.vulnerability;
  }

  toJson(): string {
    return this.toString();
  }

  toBen(): [boolean, boolean] {
    return [
      this.vulnerability === "North / South" || this.vulnerability === "All",
      this.vulnerability === "East / West" || this.vulnerability === "All",
    ];
  }

  index(): number {
    return Vulnerabilities.indexOf(this);
  }

  next(): Vulnerability {
    return Vulnerabilities[(this.index() + 1) % 4];
  }

  isVulnerable(seat: Seat): boolean {
    if (this === Vulnerability.All) {
      return true;
    }
    if (this === Vulnerability.None) {
      return false;
    }
    if (seat === Seat.North || seat === Seat.South) {
      return this === Vulnerability.NorthSouth;
    } else {
      return this === Vulnerability.EastWest;
    }
  }

  equals(other: Vulnerability) {
    return this.vulnerability === other.vulnerability;
  }
}

export const Vulnerabilities = [
  Vulnerability.None,
  Vulnerability.NorthSouth,
  Vulnerability.EastWest,
  Vulnerability.All,
];
